# 所有权

所有权是 Rust 独有的概念，需要掌握。

本文先说所有权诞生的问题背景，在介绍什么是所有权。

## 问题背景
- 计算机内存空间有限，代码运行中需要不断回收变量资源，如：函数运行完毕需要销毁函数内部的数据对象，俗称垃圾回收。
- 系统级语言功能强悍，提供了控制系统每一块内存空间的能力，从而实现高性能，代价是需要程序员自己小心翼翼的实现垃圾回收。高级语言借助各种垃圾回收算法，自动实现垃圾回收，代价是垃圾回收时机影响性能，剥夺了程序员对底层的控制能力。

Rust 是系统级语言，作为后起之秀，想做到「既要还要」，诞生了所有权的概念。

## Rust 所有权

拥有系统级语言操作底层的能力，又想轻松实现垃圾回收。它是怎么做的呢？

Rust 给出了如下限制：
- 一个值只能被一个变量所拥有，这个变量被称为所有者（Each value in Rust has a variable that’s called its owner）。
- 一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。
- 当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。（Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。记住，Rust会在作用域结束的地方（即}处）自动调用drop函数）

这三条限制意味着：一个引用对象无法被赋值多个变量。这是 Rust 和其他语言相比最大的反常识。

而一个引用对象赋值给多个变量 貌似是编程界的刚需场景，Rust 如何解决这一刚需呢？答案是用 clone，用 clone 把引用对象深 copy 一份，实现两个对象的独立从属关系。





